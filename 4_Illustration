################## 1. FIGURE 2
library(tidyverse)      # Includes dplyr, ggplot2, readr, etc.
library(funkyheatmap)   # For the main visualization
library(RColorBrewer)   # For color palettes
library(here)           # For relative path management

## Settings & Paths
INPUT_DIR  <- here("data", "results") 
OUTPUT_DIR <- here("output", "figs")

## Define the 4 Systems and 7 Crops
sys_names <- c("mono", "mono_dom", "multi", "multi_dom")
crops_indices <- 1:7 

## Helper function
build_system_df <- function(sys_name, input_dir) {
  
  crop_dfs <- lapply(crops_indices, function(i) {
    fpath <- file.path(input_dir, paste0("feashap_raw_m_", sys_name, "_", i, ".csv"))
    
    if (!file.exists(fpath)) {
      warning("File not found: ", fpath)
      return(NULL)
    }
    
    # Read and calculate mean absolute SHAP value (Global Importance)
    dat <- read.csv(fpath, check.names = FALSE)
    
    # Extract numeric columns (SHAP values)
    num_cols <- vapply(dat, is.numeric, logical(1))
    
    # Calculate Mean Absolute SHAP (Importance)
    importance <- colMeans(abs(as.matrix(dat[, num_cols, drop = FALSE])), na.rm = TRUE)
    
    data.frame(
      id = names(importance),
      value = as.numeric(importance)
    )
  })
  
  # Remove missing files
  crop_dfs <- Filter(Negate(is.null), crop_dfs)
  if (length(crop_dfs) == 0) return(NULL)
  
  # Merge the 7 crop dataframes into one (Wide format)
  combined <- Reduce(function(x, y) merge(x, y, by = "id", all = TRUE), crop_dfs)
  colnames(combined) <- c("id", paste0("crop", crops_indices))
  return(combined)
}

## Build the Master Dataframe
data_list <- lapply(sys_names, build_system_df, input_dir = INPUT_DIR)
names(data_list) <- sys_names

## Rename columns to include system suffix (e.g., crop1_mono) and merge
data_list_renamed <- lapply(names(data_list), function(nm) {
  df <- data_list[[nm]]
  colnames(df)[-1] <- paste0(colnames(df)[-1], "_", nm) 
  return(df)
})

combined_df <- Reduce(function(x, y) merge(x, y, by = "id"), data_list_renamed)

## Define standardized feature names and groups
feature_labels <- c(
  "BIO02", "BIO05", "BIO11", "BIO12", "BIO15", "GDD5", "GDD10", "GSL", 
  "CMI1", "CMI2", "CMI3", "CMI4", "IWC1", "IWC2", "IWC3","IWC4", 
  "Dem", "Slope", "Soil texture", "SOC", "Soil pH", "Soil N", "Soil P",
  "Nitrogen", "Phosphorus", "Pesticides", 
  "GDP", "Employment", "Schooling", "Farm size", "Travel time"
)

row_group_ids <- c(
  rep("set1", 8),  # Climate
  rep("set2", 8),  # Water
  rep("set3", 7),  # Environment
  rep("set4", 3),  # Inputs
  rep("set5", 5)   # Socioeconomic
)

## Apply new labels
combined_df$id <- feature_labels
combined_df$group <- factor(row_group_ids)

## Row Metadata
row_info <- tibble(
  id = feature_labels,
  group = factor(row_group_ids)
)

row_groups <- tibble(
  group = factor(paste0("set", 1:5)),
  level1 = c("Climatic variation", "Water availability", "Environmental conditions",
             "Agricultural inputs", "Socioeconomic performance")
)

## Column Metadata
crops_base <- c("Irrigated maize", "Rainfed maize", "Irrigated rice", 
                "Rainfed rice", "Rainfed soybean", "Irrigated wheat", "Rainfed wheat")

## Create column groups definition
column_groups <- tibble(
  group   = c("single", "singled", "multiple", "multipled"),
  palette = c("sin", "sin_dom", "mul", "mul_dom"),
  level1  = c("a. Single cropping\n(SC)", "b. Single cropping dominance\n(SCD)",
              "c. Multiple cropping\n(MC)", "d. Multiple cropping dominance\n(MCD)")
)

## Programmatically generate column info to avoid manual repetition
col_structure <- tibble(
  group_id = c("single", "singled", "multiple", "multipled"),
  pal_id   = c("sin", "sin_dom", "mul", "mul_dom")
)

## Expand the structure for the 7 crops per group
cols_generated <- col_structure %>%
  slice(rep(1:n(), each = 7)) %>%
  mutate(
    name = rep(crops_base, 4),
    geom = "circle",
    id   = colnames(combined_df)[-which(names(combined_df) %in% c("id", "group"))] # Auto-match cols
  )

## Add the ID/Text column at the start
column_info <- bind_rows(
  tibble(id = "id", name = "id", geom = "text", group = NA, palette = NA),
  cols_generated
)

## Define specific options (width, legend hidden)
## Default option for most cols: no legend, no scaling
default_opt <- list(legend = FALSE, scale = FALSE)
wide_opt    <- list(width = 1.3, legend = FALSE, scale = FALSE) # For specific columns if needed

## Assign options list
column_info$options <- vector("list", nrow(column_info))
column_info$options[[1]] <- list(hjust = 0, width = 5, size = 3) # Text column settings

## Apply default options to the rest
column_info$options[2:nrow(column_info)] <- list(default_opt)

## Make the "dominance" columns (singled, multipled) to be wider
dominance_indices <- which(column_info$group %in% c("singled", "multipled"))
column_info$options[dominance_indices] <- list(wide_opt)

## Color Palettes
get_mid_color <- function(brewer_name) {
  grDevices::colorRampPalette(rev(RColorBrewer::brewer.pal(9, brewer_name)))(101)[51]
}

palettes_list <- list(
  sin     = get_mid_color("Blues"),
  sin_dom = get_mid_color("Reds"),
  mul     = get_mid_color("Greens"),
  mul_dom = get_mid_color("YlOrBr")
)

## Plotting
g <- funky_heatmap(
  data = combined_df,
  column_info = column_info,
  column_groups = column_groups,
  row_info = row_info,
  row_groups = row_groups,
  palettes = palettes_list,
  add_abc = TRUE,
  position_args = position_arguments(
    col_annot_angle = 50,
    expand_xmax = 4, 
    col_annot_offset = 4
  )
)

## Save
ggsave(
  filename = file.path(OUTPUT_DIR, "shap_heatmap.pdf"), 
  plot = g, 
  device = "pdf", 
  width = g$width, 
  height = g$height
)

message("Plot saved successfully to: ", file.path(OUTPUT_DIR, "shap_heatmap.pdf"))
